# ElectricShock-Racing

Main code base of Control Unit

## 新增功能 - USB摄像头视频流监控

现在系统支持Linux平台的USB摄像头实时视频流监控功能！

### 摄像头功能特性

- ✅ USB摄像头自动检测和初始化
- ✅ 实时视频流推送到Web界面
- ✅ 可调节分辨率（320x240 至 1920x1080）
- ✅ 可调节帧率（5-60 FPS）
- ✅ JPEG压缩质量调节（10-100%）
- ✅ 多摄像头支持（索引0-10）
- ✅ 线程化处理，不影响车辆控制性能

### 如何使用摄像头功能

1. **连接USB摄像头**

   ```bash
   # 检查摄像头是否被识别
   ls /dev/video*
   # 应该看到 /dev/video0 等设备
   ```
2. **安装依赖**

   ```bash
   pip3 install -r requirements.txt
   ```
3. **启动系统**

   ```bash
   # 使用启动脚本（推荐）
   chmod +x start_linux.sh
   ./start_linux.sh

   # 或直接运行
   cd webcontroller
   python3 uart_car_control.py
   ```
4. **使用Web界面**

   - 打开浏览器访问 `http://localhost:5000`
   - 在"Camera Control"区域：
     - 点击"Initialize Camera"初始化摄像头
     - 调整分辨率、帧率等参数
     - 点击"Update Settings"应用设置
     - 点击"Start"开始视频流
     - 点击"Stop"停止视频流

### 摄像头设置参数

| 参数         | 默认值 | 范围     | 说明                                 |
| ------------ | ------ | -------- | ------------------------------------ |
| Camera Index | 0      | 0-10     | USB摄像头设备索引                    |
| Width        | 640    | 320-1920 | 视频宽度（像素）                     |
| Height       | 480    | 240-1080 | 视频高度（像素）                     |
| FPS          | 30     | 5-60     | 视频帧率                             |
| JPEG Quality | 80     | 10-100   | 压缩质量（越高越清晰但占用更多带宽） |

### 调试建议

- **低延迟调试**：使用640x480@30fps，质量50-70
- **高清监控**：使用1280x720@15fps，质量80-90
- **带宽受限**：使用320x240@15fps，质量40-60

### 故障排除

1. **摄像头无法初始化**

   ```bash
   # 检查权限
   sudo usermod -a -G video $USER
   # 注销重新登录
   ```
2. **视频流卡顿**

   - 降低分辨率或帧率
   - 降低JPEG质量
   - 检查网络连接
3. **多个摄像头**

   ```bash
   # 查看所有摄像头
   v4l2-ctl --list-devices
   # 尝试不同的Camera Index (0,1,2...)
   ```

# 项目结构

## Flask服务端

* [ ] 图像传输
* [ ] 实时控制
* [ ] 状态监控
* [ ] 数据可视化
* [ ] 在线修改参数

## 串口通讯

* [ ] 数据发送（控制）
* [ ] 数据接收（解析）

## 赛道边缘识别

* [ ] 传统算法
* [ ] 卷积模型
* [ ] 建图？

## 元素识别

* [ ] 识别模型
* [ ] 测距（定位）
* [ ] 元素控制

## 里程计

## 路径规划器

* [ ] 目标路径规划
* [ ] 速度规划

## 核心控制器

# 官方上位机代码架构分析

## 智能车上位机项目系统架构分析

### 1. 项目概述

这是一个基于**百度EdgeBoard**硬件平台的智能车竞赛项目，采用**C++**开发，集成了**计算机视觉**、**AI目标检测**、**运动控制**和**串口通信**等技术。

### 2. 系统架构图

```
┌─────────────────────────────────────────────────────────────┐
│                     智能车上位机系统                          │
├─────────────────────────────────────────────────────────────┤
│  主控制模块 (icar.cpp)                                       │
│  ├── 初始化 → 图像采集 → 预处理 → AI推理 → 场景识别 → 控制输出 │
└─────────────────────────────────────────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
┌───────▼──────┐    ┌────────▼─────────┐    ┌──────▼──────┐
│  图像处理层   │    │    AI检测层      │    │  控制决策层  │
│ Preprocess   │    │   Detection      │    │ControlCenter│
│ Tracking     │    │   场景检测模块     │    │   Motion    │
└──────────────┘    └──────────────────┘    └─────────────┘
        │                     │                     │
        └─────────────────────┼─────────────────────┘
                              │
┌─────────────────────────────▼─────────────────────────────┐
│                   硬件接口层                               │
│  Camera (USB摄像头) │ Uart (串口通信) │ Display (调试界面)  │
└───────────────────────────────────────────────────────────┘
```

### 3. 核心模块功能分析

#### 3.1 主控制模块 (icar.cpp)

- **功能**: 系统顶层调度器，协调各个子模块
- **流程**:
  1. 初始化各子系统（相机、串口、AI模型）
  2. 实时图像采集和处理
  3. 场景状态机管理（9种场景切换）
  4. 控制指令生成和发送

#### 3.2 图像处理层

- **Preprocess** (preprocess.cpp):

  - 相机标定和图像矫正
  - RGB转灰度图
  - 图像二值化处理
- **Tracking** (tracking.cpp):

  - 赛道边缘检测
  - 赛道中心线提取
  - 岔路信息识别

#### 3.3 AI检测层

- **Detection** (detection.hpp):

  - 基于**Paddle + ONNX**的目标检测
  - 支持10种目标类别（充电站、障碍物、坡道等）
  - 多模型融合推理
- **场景检测模块**:

  - bridge.cpp: 坡道检测
  - obstacle.cpp: 障碍区检测
  - catering.cpp: 快餐店检测
  - layby.cpp: 临时停车区检测
  - parking.cpp: 充电停车场检测
  - crosswalk.cpp: 停车区检测

#### 3.4 路径规划层

- **Crossroad** (crossroad.cpp): 十字路口识别与路径规划
- **Ring** (ring.cpp): 环岛识别与路径规划（5步状态机）

#### 3.5 控制决策层

- **ControlCenter** (controlcenter.cpp):

  - 赛道中心线拟合（贝塞尔曲线）
  - 控制中心计算
  - 方差分析和有效行优化
- **Motion** (motion.cpp):

  - PD控制器实现
  - 多场景速度控制
  - 参数配置管理

#### 3.6 硬件接口层

- **Uart** (uart.hpp):
  - 串口通信协议
  - 车辆运动控制（速度+转向）
  - 蜂鸣器和LED控制
  - 按键状态读取

### 4. 数据流和模块连接

```
┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
│USB Camera│─▶│Preprocess│──▶│ Tracking │-─▶│ Motion   │
└──────────┘    └──────────┘    └──────────┘    └──────────┘
                       │                               │
                       ▼                               ▼
                ┌──────────┐                   ┌──────────┐
                │Detection │                   │   Uart   │
                └──────────┘                   └──────────┘
                       │                               │
                       ▼                               ▼
                ┌──────────┐                   ┌──────────┐
                │Scene Det.│                   │  Hardware│
                └──────────┘                   └──────────┘
                       │
                       ▼
                ┌──────────┐
                │CtrlCenter│
                └──────────┘
```

### 5. 状态机设计

项目采用**场景状态机**设计，包含9种场景：

```cpp
enum Scene {
    NormalScene = 0,    // 基础赛道
    CrossScene,         // 十字道路  
    RingScene,          // 环岛道路
    BridgeScene,        // 坡道区
    ObstacleScene,      // 障碍区
    CateringScene,      // 快餐店
    LaybyScene,         // 临时停车区
    ParkingScene,       // 停车区
    StopScene           // 停车（结束）
};
```

### 6. 配置管理

- **参数化配置** (config.json): 速度参数、PID参数、使能开关
- **模型配置**: AI模型路径、推理参数配置
- **相机标定**: 内参矩阵、畸变系数

### 7. 开发参考建议

#### 7.1 架构优势

1. **模块化设计**: 功能模块独立，便于维护和扩展
2. **状态机管理**: 清晰的场景切换逻辑
3. **参数化配置**: 便于调试和优化
4. **多传感器融合**: 视觉+AI双重感知

#### 7.2 核心技术栈

- **开发语言**: C++17
- **视觉库**: OpenCV 4.x
- **AI推理**: Paddle + ONNX Runtime
- **硬件接口**: LibSerial (串口通信)
- **构建系统**: CMake

#### 7.3 可复用的设计模式

1. **工厂模式**: Detection类的模型加载
2. **状态机模式**: Scene枚举和状态切换
3. **策略模式**: 不同场景的处理策略
4. **观察者模式**: 调试界面的实时显示

这个项目为智能车竞赛提供了完整的软件架构参考，您可以基于此架构开发类似的自动驾驶或机器人导航项目。
