import cv2
import numpy as np

# 读取保存的标定参数
data = np.load('calib_params.npz')
mtx = data['mtx']
dist = data['dist']

import numpy as np
import cv2
import textwrap

# --- 1. 用户配置区 ---
# 请在此处填入你的实际参数

# 原始高分辨率 (标定时使用的分辨率)
ORIG_WIDTH = 1024
ORIG_HEIGHT = 768

# 目标低分辨率 (最终处理时使用的分辨率)
TARGET_WIDTH = 640
TARGET_HEIGHT = 480

# 原始高分辨率下的相机内参矩阵 (mtx)
MTX_ORIG = mtx

# 畸变系数 (dist) - 这个与分辨率无关
DIST_COEFFS = dist

# --- 2. 计算过程 ---

def calculate_and_generate_code():
    """
    计算缩放后的参数并生成C++代码
    """
    print("--- [Step 1] Scaling camera matrix...")
    # 复制原始矩阵以进行修改
    mtx_scaled = MTX_ORIG.copy()

    # 计算缩放比例
    scale_x = TARGET_WIDTH / ORIG_WIDTH
    scale_y = TARGET_HEIGHT / ORIG_HEIGHT

    # 缩放内参矩阵的 fx, fy, cx, cy
    mtx_scaled[0, 0] *= scale_x  # fx
    mtx_scaled[1, 1] *= scale_y  # fy
    mtx_scaled[0, 2] *= scale_x  # cx
    mtx_scaled[1, 2] *= scale_y  # cy
    
    print(f"Original Mtx:\n{MTX_ORIG}")
    print(f"Scaled Mtx for {TARGET_WIDTH}x{TARGET_HEIGHT}:\n{mtx_scaled}\n")

    print("--- [Step 2] Calculating optimal new matrix and ROI for target resolution...")
    # 使用缩放后的参数计算新的最佳相机矩阵和ROI
    # alpha=1 表示保留所有原始像素，可能会有黑边，但这是与您原始代码等效的做法
    new_mtx_scaled, roi = cv2.getOptimalNewCameraMatrix(
        cameraMatrix=mtx_scaled,
        distCoeffs=DIST_COEFFS,
        imageSize=(TARGET_WIDTH, TARGET_HEIGHT),
        alpha=1,
        newImgSize=(TARGET_WIDTH, TARGET_HEIGHT)
    )
    
    # ROI (x, y, w, h)
    roi_x, roi_y, roi_w, roi_h = roi

    print(f"Optimal New Mtx for {TARGET_WIDTH}x{TARGET_HEIGHT}:\n{new_mtx_scaled}")
    print(f"ROI for cropping: x={roi_x}, y={roi_y}, w={roi_w}, h={roi_h}\n")

    print("--- [Step 3] Generating C++ Code ---\n")
    generate_cpp(mtx_scaled, DIST_COEFFS, new_mtx_scaled, roi)

def format_mat_for_cpp(mat, name, dtype="double"):
    """将numpy矩阵格式化为C++ cv::Mat初始化代码"""
    rows, cols = mat.shape
    mat_data = ", ".join(map(str, mat.flatten()))
    return f"const cv::Mat {name} = (cv::Mat_<{dtype}>({rows}, {cols}) << {mat_data});"

def generate_cpp(mtx, dist, new_mtx, roi):
    """生成最终的C++代码字符串"""
    
    cpp_code = f"""
// =================================================================================
//      Pre-computed Camera Calibration Parameters for {TARGET_WIDTH}x{TARGET_HEIGHT} Resolution
//      Generated by Python script. Do not modify these values manually.
// =================================================================================

// Scaled camera matrix for {TARGET_WIDTH}x{TARGET_HEIGHT} input images.
{format_mat_for_cpp(mtx, "PRECOMPUTED_MTX_LOW_RES")}

// Distortion coefficients (resolution-independent).
{format_mat_for_cpp(dist, "PRECOMPUTED_DIST")}

// Optimal new camera matrix for undistortion at {TARGET_WIDTH}x{TARGET_HEIGHT}.
{format_mat_for_cpp(new_mtx, "PRECOMPUTED_NEW_MTX_LOW_RES")}

// Region of Interest (ROI) for cropping black borders at {TARGET_WIDTH}x{TARGET_HEIGHT}.
const cv::Rect PRECOMPUTED_ROI_LOW_RES = (cv::Rect({roi[0]}, {roi[1]}, {roi[2]}, {roi[3]}));


/**
 * @brief (Highly Optimized) Undistorts and crops a low-resolution image using pre-computed parameters.
 *
 * This function is extremely fast as it avoids any on-the-fly calculations.
 * It assumes the input image is already resized to the target resolution ({TARGET_WIDTH}x{TARGET_HEIGHT}).
 *
 * @param img_low_res The distorted input image, which MUST be {TARGET_WIDTH}x{TARGET_HEIGHT}.
 * @return cv::Mat The undistorted and cropped image.
 */
cv::Mat undistortWithPrecomputedParams(const cv::Mat& img_low_res)
{{
    // 1. Undistort the low-resolution image using the pre-calculated matrices.
    cv::Mat dst;
    cv::undistort(img_low_res, dst, PRECOMPUTED_MTX_LOW_RES, PRECOMPUTED_DIST, PRECOMPUTED_NEW_MTX_LOW_RES);

    // 2. Crop to the valid region using the pre-calculated ROI.
    // .clone() creates a deep copy, making the returned Mat independent.
    cv::Mat cropped_dst = dst(PRECOMPUTED_ROI_LOW_RES).clone();

    return cropped_dst;
}}

// ======================= EXAMPLE USAGE (main function) ==========================
/*
#include <opencv2/opencv.hpp>
#include <iostream>

// (Paste the generated code block above this main function)

int main()
{{
    // 1. Read a high-resolution distorted image.
    // Replace with your actual image path.
    cv::Mat high_res_img = cv::imread("your_distorted_image_1024x768.jpg");
    if (high_res_img.empty())
    {{
        std::cerr << "Error: Could not read the image." << std::endl;
        return -1;
    }}

    // 2. Resize the image to the target resolution FIRST.
    // This is the key to performance.
    cv::Mat low_res_img;
    cv::resize(high_res_img, low_res_img, cv::Size({TARGET_WIDTH}, {TARGET_HEIGHT}), 0, 0, cv::INTER_LINEAR);

    // 3. Call the highly optimized undistortion function.
    cv::Mat final_result = undistortWithPrecomputedParams(low_res_img);

    // 4. Display the results.
    cv::imshow("Original High-Res Image", high_res_img);
    cv::imshow("Resized (but still distorted) Low-Res Image", low_res_img);
    cv::imshow("Final Undistorted and Cropped Result", final_result);

    std::cout << "Process finished. Final image size: " << final_result.size() << std::endl;
    cv::waitKey(0);

    return 0;
}}
*/
"""
    # 使用textwrap.dedent来移除由于f-string引起的多余缩进
    print(textwrap.dedent(cpp_code).strip())


# --- 3. 运行脚本 ---
if __name__ == "__main__":
    calculate_and_generate_code()


# 保存标定参数为XML文件
# fs = cv2.FileStorage('calibration_parameters.xml', cv2.FILE_STORAGE_WRITE)
# fs.write('cameraMatrix', mtx)
# fs.write('distCoeffs', dist)
# fs.release()
# print("Camera calibration parameters saved to calibration_parameters.xml")



# # 读一张要校正的照片
# img = cv2.imread('./calib_imgs/calib_01.jpg')  # 换成你实际图片路径
# h, w = img.shape[:2]

# # 计算新的校正映射
# newcameramtx, roi = cv2.getOptimalNewCameraMatrix(mtx, dist, (w,h), 1, (w,h))

# # 去畸变
# dst = cv2.undistort(img, mtx, dist, None, newcameramtx)

# # 裁剪有效区域（可选）
# x, y, w, h = roi
# dst = dst[y:y+h, x:x+w]

# cv2.imshow('Undistorted', dst)
# cv2.waitKey(0)
# cv2.destroyAllWindows()
# cv2.imwrite('./undistorted_01.jpg', dst)
